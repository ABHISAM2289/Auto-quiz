<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Quiz</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }
        
        h1 {
            color: white;
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .nav-section {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 600px;
        }
        
        .nav-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 180px;
            justify-content: center;
        }
        
        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        
        .nav-btn.summarizer {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .nav-btn.quiz {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .divider {
            width: 100%;
            max-width: 600px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ddd, transparent);
            margin: 20px 0;
        }

        form {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            width: 90%;
            max-width: 500px;
        }
        
        /* Enhanced file input styling - Royal/Professional */
        .file-input {
            position: relative;
            font-size: 1rem;
            padding: 20px 30px;
            border-radius: 8px;
            border: 2px solid #2c3e50;
            width: 100%;
            max-width: 350px;
            box-sizing: border-box;
            background: linear-gradient(145deg, #34495e 0%, #2c3e50 100%);
            color: #ecf0f1;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 32px rgba(44, 62, 80, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }
        
        .file-input::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(236, 240, 241, 0.1), transparent);
            transition: left 0.6s ease;
        }
        
        .file-input:hover::after {
            left: 100%;
        }
        
        .file-input:hover {
            border-color: #34495e;
            background: linear-gradient(145deg, #3c4f64 0%, #34495e 100%);
            transform: translateY(-3px);
            box-shadow: 
                0 12px 40px rgba(44, 62, 80, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }
        
        .file-input::file-selector-button {
            display: none;
        }
        
        .file-input::before {
            content: 'SELECT AUDIO FILE';
            display: block;
            font-size: 1rem;
            font-weight: 700;
            color: #ecf0f1;
            letter-spacing: 1.5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            font-family: 'Segoe UI', serif;
        }
        
        .file-input:hover::before {
            color: #f8f9fa;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        
        .file-input:active {
            transform: translateY(-1px);
            box-shadow: 
                0 6px 20px rgba(44, 62, 80, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }
        
        input[type="file"], .form-button {
            font-size: 1rem;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ccc;
            width: 100%;
            max-width: 300px;
            box-sizing: border-box;
        }
        
        .form-button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .form-button:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }
        
        #mic-btn {
            background-color: #28a745;
        }
        
        #mic-btn:hover {
            background-color: #218838;
        }

        #mic-btn.recording {
            background-color: #dc3545;
            animation: pulse 1s infinite;
        }
        
        #mic-btn.recording:hover {
            background-color: #c82333;
        }
        
        #mic-btn.upload-ready {
            background-color: #007bff;
        }

        #mic-btn.upload-ready:hover {
            background-color: #0056b3;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.5); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        
        .output {
            margin-top: 30px;
            width: 90%;
            max-width: 700px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .output p {
            margin: 0 0 15px;
            font-size: 1rem;
        }
        
        #status {
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .status-initial { color: #666; background-color: #f0f0f0; }
        .status-processing { color: #007bff; background-color: #e0f0ff; }
        .status-done { color: #28a745; background-color: #e6ffe6; }
        .status-error { color: #dc3545; background-color: #ffe6e6; }
        .status-warning { color: #ffc107; background-color: #fff8e6; }

        audio {
            margin-top: 15px;
            width: 100%;
        }
        
        #transcript {
            white-space: pre-wrap;
            font-size: 1rem;
            margin-top: 15px;
            line-height: 1.6;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            overflow-x: auto;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .nav-section {
                flex-direction: column;
                align-items: center;
            }
            
            .nav-btn {
                width: 100%;
                max-width: 300px;
            }

            h1 {
                font-size: 2rem;
            }
            .subtitle {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <h1>
        <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic text-purple-600">
            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
            <line x1="12" x2="12" y1="19" y2="22"/>
        </svg>
        Auto Quiz
    </h1>
    <p class="subtitle">Transcribe, Summarize, and Create Quizzes from Audio Content</p>
    
    <div class="nav-section">
        <a href="http://localhost:5002" class="nav-btn summarizer">
            üìù Summarizer
        </a>
        <a href="http://localhost:5003" class="nav-btn quiz">
            üß† Quiz Engine
        </a>
    </div>
    
    <div class="divider"></div>

    <form id="upload-form">
        <input type="file" name="file" id="file-input" accept="audio/*,video/*" class="file-input">
        
        <button type="button" id="mic-btn" class="form-button">
            üéôÔ∏è Record Audio
        </button>
        <button type="submit" id="upload-file-btn" class="form-button">
            ‚è´ Upload Selected File
            <span id="upload-spinner" class="spinner hidden"></span>
        </button>
    </form>

    <div class="output">
        <p id="status" class="status-initial">Waiting for input...</p>
        <p><strong>Transcript:</strong></p>
        <div id="transcript"></div>
        <audio id="audio-player" controls style="display:none;"></audio>
    </div>

    <script>
        const form = document.getElementById("upload-form");
        const micBtn = document.getElementById("mic-btn");
        const fileInput = document.getElementById("file-input"); 
        const statusDiv = document.getElementById("status");
        const transcriptDiv = document.getElementById("transcript");
        const audioPlayer = document.getElementById("audio-player");
        const uploadFileBtn = document.getElementById("upload-file-btn"); 
        const uploadSpinner = document.getElementById("upload-spinner");

        let mediaRecorder;
        let recordedChunks = [];
        let recordedBlob = null; 
        let pollingIntervalId = null;

        function updateStatus(message, type = 'initial') {
            statusDiv.textContent = message;
            statusDiv.className = `status-${type}`;
        }

        function handleAudioPlayerError(event) {
            console.error("Audio player error:", event.target.error);
            
            audioPlayer.style.display = "none";
            
        }

        function resetFormState() {
            uploadFileBtn.disabled = false;
            fileInput.disabled = false;
            micBtn.disabled = false;
            uploadSpinner.classList.add('hidden');
            fileInput.value = '';
            recordedBlob = null;
            micBtn.innerHTML = 'üéôÔ∏è Record Audio';
            micBtn.classList.remove("recording", "upload-ready");
            audioPlayer.style.display = "none";
            audioPlayer.src = "";
            if (pollingIntervalId) {
                clearInterval(pollingIntervalId);
                pollingIntervalId = null;
            }
        }

        
        function getRecordingFormat() {
            
            const formats = [
                'audio/wav',              
                'audio/mp4',              
                'audio/webm; codecs=opus', 
                'audio/webm',             
                'audio/ogg'               
            ];

            for (const format of formats) {
                if (MediaRecorder.isTypeSupported(format)) {
                    console.log(`Selected recording format: ${format}`);
                    return format;
                }
            }
            
            console.error("No supported audio recording format found.");
            return null;
        }

        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                micBtn.disabled = true;
                micBtn.innerHTML = 'üéôÔ∏è Record Audio';
                micBtn.classList.remove("recording", "upload-ready");
                recordedBlob = null;
                audioPlayer.style.display = "none";
                audioPlayer.src = "";
                updateStatus("File selected. Ready to upload.", "initial");
            } else {
                micBtn.disabled = false;
                updateStatus("Waiting for input...", "initial");
            }
        });

        micBtn.addEventListener("click", async () => {
            
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                micBtn.classList.remove("recording");
                micBtn.classList.add("upload-ready");
                micBtn.innerHTML = '‚¨ÜÔ∏è Upload Recorded Audio';
                updateStatus("üé§ Recording finished. Processing...", 'processing');
                
                
                setTimeout(() => {
                    if (recordedBlob) {
                       
                        try {
                            const audioURL = URL.createObjectURL(recordedBlob);
                            audioPlayer.src = audioURL;
                            audioPlayer.style.display = "block";
                            updateStatus("üé§ Recording finished. Click 'Upload Recorded Audio'.", 'done');
                        } catch (e) {
                            console.error("Error creating audio URL:", e);
                            
                            updateStatus("üé§ Recording finished. Click 'Upload Recorded Audio'.", 'done');
                        }
                    }
                }, 100);

                fileInput.disabled = false;
                uploadFileBtn.disabled = false;
                return;
            }

            
            if (recordedBlob && micBtn.classList.contains("upload-ready")) {
                
                const fileName = recordedBlob.type.includes('wav') ? 'recorded_audio.wav' : 'recorded_audio.webm';
                await submitAudio(new File([recordedBlob], fileName, { type: recordedBlob.type }), true);
                return;
            }

            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                recordedChunks = [];
                
                const format = getRecordingFormat();
                if (!format) {
                    updateStatus("‚ùå Your browser does not support audio recording.", 'error');
                    stream.getTracks().forEach(track => track.stop());
                    return;
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType: format });
                console.log(`Recording with format: ${format}`);

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                        console.log(`Recorded chunk: ${e.data.size} bytes`);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedBlob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
                    console.log("Recording stopped. Blob type:", recordedBlob.type, "size:", recordedBlob.size);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.onerror = (e) => {
                    console.error("MediaRecorder error:", e);
                    updateStatus("‚ùå Recording error occurred.", 'error');
                    resetFormState();
                };

                fileInput.disabled = true;
                uploadFileBtn.disabled = true;
                recordedBlob = null;
                
                mediaRecorder.start(1000); 
                micBtn.classList.add("recording");
                micBtn.classList.remove("upload-ready");
                micBtn.innerHTML = '‚èπÔ∏è Stop Recording <span class="spinner"></span>';
                updateStatus("üéôÔ∏è Recording in progress...", 'processing');
                
            } catch (err) {
                console.error("Microphone access denied:", err);
                updateStatus("‚ùå Microphone access denied. Please allow permissions in your browser settings.", 'error');
                resetFormState();
            }
        });

        form.onsubmit = async (e) => {
            e.preventDefault();

            if (fileInput.files.length > 0) {
                await submitAudio(fileInput.files[0], false);
            } else {
                updateStatus("‚ùå Please select a file or record audio first.", 'error');
                resetFormState();
            }
        };

        async function submitAudio(fileToUpload, isMicUpload) {
            updateStatus("‚è≥ Uploading audio...", 'processing');
            transcriptDiv.innerText = "";
            audioPlayer.style.display = "none";

            uploadFileBtn.disabled = true;
            micBtn.disabled = true;
            uploadSpinner.classList.remove('hidden');

            const formData = new FormData();
            formData.append("file", fileToUpload);
            formData.append("mic_mode", isMicUpload ? "true" : "false");
            
            console.log("Submitting file:", fileToUpload.name, "Type:", fileToUpload.type, "Size:", fileToUpload.size, "mic_mode:", isMicUpload);

            try {
                const uploadRes = await fetch("/transcribe", {
                    method: "POST",
                    body: formData,
                });

                if (!uploadRes.ok) {
                    const errorData = await uploadRes.json();
                    updateStatus(`‚ùå Upload failed: ${errorData.error || 'Unknown error'}`, 'error');
                    resetFormState();
                    return;
                }

                const { job_id, estimated_duration_minutes } = await uploadRes.json();
                let durationMessage = estimated_duration_minutes > 0 ? `Estimated duration: ${estimated_duration_minutes} minutes.` : "Duration unknown (microphone audio).";
                updateStatus(`‚è≥ Audio uploaded. Job ID: ${job_id}. ${durationMessage} Starting transcription...`, 'processing');
                
                if (pollingIntervalId) {
                    clearInterval(pollingIntervalId);
                }
                pollUntilReady(job_id, estimated_duration_minutes);

            } catch (err) {
                console.error("Upload error:", err);
                updateStatus("‚ùå Upload failed. Please check your connection and try again.", 'error');
                resetFormState();
            }
        }

        async function pollUntilReady(jobId, estimatedDurationMinutes) {
            const pollInterval = 5000;
            let elapsedSeconds = 0;
            const maxPollingSeconds = 32400;

            pollingIntervalId = setInterval(async () => {
                elapsedSeconds += (pollInterval / 1000);
                
                if (elapsedSeconds > maxPollingSeconds) {
                    clearInterval(pollingIntervalId);
                    updateStatus("‚ùå Transcription timed out on the client-side. The backend might still be processing. Please check logs or try fetching the latest transcript later.", 'error');
                    resetFormState();
                    return;
                }

                try {
                    const res = await fetch(`/status/${jobId}`);
                    const data = await res.json();

                    if (!res.ok) {
                        console.error(`Error from status endpoint for job ${jobId}:`, data.error);
                        updateStatus(`‚ö†Ô∏è Error checking status for job ${jobId}: ${data.error || 'Unknown error'}. Retrying...`, 'warning');
                        return;
                    }

                    if (data.status === "done") {
                        clearInterval(pollingIntervalId);
                        updateStatus("‚úÖ Transcription completed successfully!", 'done');
                        transcriptDiv.innerText = data.transcript || "(No transcript generated)";
                        resetFormState();
                        
                    } else if (data.status === "error") {
                        clearInterval(pollingIntervalId);
                        updateStatus(`‚ùå Transcription failed: ${data.error || 'Unknown error'}`, 'error');
                        transcriptDiv.innerText = data.transcript || "(Error loading transcript)";
                        resetFormState();
                    } else {
                        let currentBackendStatus = data.status || "processing";
                        let progressMessage = "";
                        if (data.progress !== undefined) {
                            progressMessage = ` (${data.progress.toFixed(1)}%)`;
                        }
                        updateStatus(`‚è≥ Status: ${currentBackendStatus.charAt(0).toUpperCase() + currentBackendStatus.slice(1).replace(/_/g, ' ')}. Elapsed: ${Math.floor(elapsedSeconds / 60)}m ${Math.floor(elapsedSeconds % 60)}s${progressMessage}`, 'processing');
                        
                        if (data.transcript) {
                            transcriptDiv.innerText = data.transcript;
                        }
                    }
                } catch (err) {
                    console.error("Polling network error:", err);
                    updateStatus(`‚è≥ Processing... (connection issues, retrying). Elapsed: ${Math.floor(elapsedSeconds / 60)}m ${Math.floor(elapsedSeconds % 60)}s`, 'warning');
                }
            }, pollInterval);
        }

        updateStatus("Waiting for input...", 'initial');
    </script>
</body>
</html>